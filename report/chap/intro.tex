\chapter{Introduction}

Two player (adversarial, perfect information) games are useful in Logic. For example the truth value of a formula $\phi \equiv \exists x \, \forall y \, \exists z \, (y \cdot z = x)$ on a structure $(\Nat,\cdot)_=$ can be described by the following two player game. The players are called $P_\exists,P_\forall$ respectively. First $P_\exists$ chooses an $x \in \Int$, then $P_\forall$ chooses an $y \in \Int$ and finally $P_\exists$ chooses an $z \in \Int$. $P_\exists$ wins the resulting play when $y \cdot z = x$, otherwise $P_\forall$ wins. Observe that $\phi$ is true exactly when $P_\exists$ has a winning strategy in this game. This shows how Games are related to quantifier alternation. Similarly, the acceptance conditions for Alternating automata can also be described a game.

This analysis is very useful in the infinite case. B\"uchi \cite{richard_buchi_symposium_1966} used automata on infinite words to give a decision procedure for S1S  -- the MSO (Monadic second order) theory of natural numbers $(\Nat,S)_=$ with successor function $S(x) := x+1$ and equality. MSO means that apart from first order quantification $\exists x$, terms like $x \in A$ and quantification $\exists A$ are also allowed over set variables $A$. Later, Rabin \cite{rabin_decidability_1969} used automata on infinite trees to give a similar decision procedure for S2S -- the MSO theory on the infinite binary tree $(\set{0,1}^*,S_0,S_1)_=$ where $S_0(x)=x0$ and $S_1(x)=x1$ are left and right successors. The decidability of S2S is a powerful result. Many interesting logics can be decided by interpreting into S2S (see \cite{rabin_decidability_1969},\cite[Chap~7]{classical_prob}). Rabin's original proof is complicated. The combinatorics of the hardest part -- The complementation lemma for Tree automata can be neatly simplified using infinite (duration) games \cite[Chap~8]{thomas2002automata}. The acceptance condition for the Tree automata is interpreted as a Parity game (introduced in \Cref{chap:par}); this allows to use the results on Parity games for the emptiness and complementation problem of the Tree automata.

Another important application of Infinite games is the Synthesis problem for Reactive systems. Reactive systems are computer systems that continuously interact with the environment, e.g., Lift Controller and an Operating System. An execution of such a system can be captured by an infinite string $(\mc{I} \times \mc{O})^\omega$ of input/output pairs over the input alphabet $\mc{I}$ and output alphabet $\mc{O}$. The desired behaviour of such a system is given by a specification $Spec \subseteq (\mc{I} \times \mc{O})^\omega$. Given $Spec$, the Synthesis problem is to find an $f: \mc{I}^* \mapsto \mc{O}$ (if it exists)  so that for any input sequence $i_0i_1 \ldots \in \mc{I}^\omega$ the input/output sequence  $(i_0,f(i_0))(i_1,f(i_0i_1))(i_2,f(i_0i_1i_2)) \ldots \in Spec$. Intuitively we want an algorithm that when presented with a (finite description of) $Spec$ finds an implementation $f$ satisfying $Spec$ or concludes that there is none.

When $Spec$ is expressed in S1S (or LTL), \cite{synthesis} showed that Synthesis problem is decidable. The idea is to express the Synthesis problem as an infinite game between the Environment and the System (designer). The turns of Environment and System alternate during the game. Initially the Environment picks $i_1 \in \mc{I}$, then the System picks $o_1 \in \mc{O}$. Then the Environment picks $i_2 \in \mc{I}$ and the System picks $o_2 \in \mc{O}$, and the game thus continues. If $(i_1,o_1)(i_2,o_2) \ldots \in Spec$ then the play is winning for System else the Environment wins. Observe that implementations ($f$) satisfying $Spec$ are exactly the winning strategies for the System in this game. Hence this reduces the Synthesis problem to finding the winning strategy in an infinite game. Since $Spec$ is expressed in S1S, $Spec$ is an $\omega$-regular set. For $\omega$-regular winning conditions on finite graphs (as is the case here) there are algorithms to compute the winning strategies.

Hence algorithms to decide the winner and find the winning strategies in (finitely presented) infinite games are of importance. We will keep this mind while discussing infinite games. \Cref{chap:formalism} will provide a general formalism for infinite games on graphs. In \Cref{chap:par} we discuss Parity games. Parity games may not be the most intuitive games to start with (see \cite[Chap~2]{thomas2002automata} for Reachability and B\"uchi games), but they are powerful enough to express $\omega$-regular winning conditions (via deterministic parity automata) and yet have positional winning strategies. The problem of deciding the winner of Parity games is in $\NP \cap \coNP$ (hence unlikely to be $\NP$-complete), but it is not know whether (or not) a polynomial time algorithm exists. An efficient algorithm for deciding the winner and winning strategies for Parity games will help improve the runtime for the algorithms mentioned above, and for many others which rely on infinite games.

\Cref{chap:mean} and \Cref{chap:disc} discuss Mean and Discounted Payoff games. Although these games are no longer Win-Lose games, they are related to Parity games. Algorithms for such games can be useful for more general Controller-Synthesis problems with Quantitative objectives.

